
#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	Если Параметры.Свойство("Проект") Тогда
		Проект = Параметры.Проект;
	КонецЕсли;	
	
КонецПроцедуры

#КонецОбласти

#Область МеханизмЧтенияФайла

// Метод "1C836" для файлов EXCEL с расширениями: xlsx, xls, ods.
//
// Параметры:
//         ФайлEXCEL - Полное имя файла (путь к файлу с именем файла и расширением).
//        СтрокаЗаголовка (по умолчанию = 1) - Номер строки файла типа MXL, в которой расположены заголовки колонок.
//            Не используется. 
//      В обработке 1-я строка анализируется для сопоставления колонок файла с реквизитами объектов 1С.
//        НачСтрока (по-умолчанию = 0) - Номер начальной строки, начиная с которой считываются данные из файла.
//        КонСтрока (по-умолчанию = 0) - Номер конечной строки, которой заканчиваются считываемые данные из файла.
//            Если НачСтрока=0 и КонСтрока=0, то считывается вся таблица, находящаяся в файле.
//        КолвоСтрокФайла - Количество строк в файле. Возвращается в вызвавшую процедуру.
//
// Возвращаемые значения:
//         ТаблицаРезультат - Результат считывания данных из файла.
//
&НаСервере
Функция ЗагрузитьМетодом_1C836(Знач ФайлEXCEL, ЕстьСтрокаЗаголовка = Ложь, НачСтрока = 0, КонСтрока = 0, КолвоСтрокФайла = 0)
    Перем ТабличныйДокумент, КонечнаяКолонка, ИмяКолонки, Область, ТекущаяОбласть, нСтрока, нКолонка, НоваяСтрокаТФ, ЗначениеЯчейки;
    Перем ТаблицаРезультат;
	
    ТабличныйДокумент = Новый ТабличныйДокумент;
    Попытка
        ТабличныйДокумент.Прочитать(ФайлEXCEL, СпособЧтенияЗначенийТабличногоДокумента.Значение);    // СпособЧтенияЗначенийТабличногоДокумента - новый параметр платформы 8.3.6. Второе значение "Текст".
    Исключение
        Сообщить(ОписаниеОшибки(), СтатусСообщения.Внимание);
        Возврат Новый ТаблицаЗначений;
    КонецПопытки;
    
    КолвоСтрокФайла = ТабличныйДокумент.ВысотаТаблицы;
    КонечнаяКолонка = ТабличныйДокумент.ПолучитьОбласть().ШиринаТаблицы;
    
    // Проверка заполненности листа.
    Если КолвоСтрокФайла = 0 Тогда
        // Завершение работы.
        // Закрытие Объектов.
        ТабличныйДокумент = Неопределено;
        Возврат Новый ТаблицаЗначений;    // В случае ошибки возвращаем пустую таблицу значений.
    КонецЕсли;
    
    // Создание результирующей таблицы, в которую будут записываться считанные из файла данные.
    ТаблицаРезультат = Новый ТаблицаЗначений;
    
    // Формирование колонок результирующей таблицы.
    
    // "НомерСтроки" - для наглядности и удобства.
    // В зависимости от разрабатываемой обработки.
    // "Сопоставлено" - может быть другим.
    // Здесь же могут быть добавлены другие колонки, не формируемые из содержимого файла.
	ТаблицаРезультат.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"), "№", 4);
	//ТаблицаРезультат.Колонки.Добавить("Сопоставлено", Новый ОписаниеТипов("Булево"), "Сопоставлено", 1);
    
    Для ит = 1 ПО КонечнаяКолонка Цикл
        нКолонка = СтрЗаменить(ит, Символы.НПП, "");
        ИмяКолонки = "N" + нКолонка;
        ТаблицаРезультат.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(50)));
	КонецЦикла;
	
	ВыделятьВСписке = Истина;
	Если ВыделятьВСписке Тогда
		ТаблицаРезультат.Колонки.Добавить("ВыделятьВСписке", Новый ОписаниеТипов("Булево"), "Выделять", 5);
	КонецЕсли;	
		
    
    // 1-я строка. Заголовки.
	Если ЕстьСтрокаЗаголовка Тогда
		
		НоваяСтрокаТФ = ТаблицаРезультат.Добавить();
		НоваяСтрокаТФ.НомерСтроки = 1;
		Для ит=1 ПО КонечнаяКолонка Цикл
			нКолонка = СтрЗаменить(ит, Символы.НПП, "");
			ИмяКолонки = "N" + нКолонка;
			НоваяСтрокаТФ[ИмяКолонки] = ТабличныйДокумент.ПолучитьОбласть("R1" + "C"+нКолонка).ТекущаяОбласть.Текст;
			
			// Используется при формировании таблицы на форме обработки.
			ШиринаКолонки = ТаблицаРезультат.Колонки[ИмяКолонки].Ширина;
			ДлинаСтроки    = СтрДлина(СокрЛП(НоваяСтрокаТФ[ИмяКолонки]));
			ТаблицаРезультат.Колонки[ИмяКолонки].Ширина = ?(ШиринаКолонки < ДлинаСтроки, ДлинаСтроки, ШиринаКолонки);
    	КонецЦикла;

	КонецЕсли;
	    
    НачСтрока = ?(НачСтрока = 0, 2, НачСтрока);
    КонСтрока = ?(КонСтрока = 0, КолвоСтрокФайла, КонСтрока);
    
    Для нСтрока = НачСтрока ПО КонСтрока Цикл
        НоваяСтрокаТФ = ТаблицаРезультат.Добавить();
        НоваяСтрокаТФ[0] = нСтрока;
        Для ит=1 ПО КонечнаяКолонка Цикл
            нКолонка = СтрЗаменить(ит, Символы.НПП, "");
            Область = ТабличныйДокумент.ПолучитьОбласть("R"+СтрЗаменить(нСтрока, Символы.НПП, "") + "C"+нКолонка);
            ТекущаяОбласть = Область.ТекущаяОбласть;
            Попытка
                ЗначениеЯчейки = ТекущаяОбласть.Значение;        // Число, Дата.
            Исключение
                ЗначениеЯчейки = СокрЛП(ТекущаяОбласть.Текст);    // Строка, Булево. (Булево как строка "ИСТИНА"/"ЛОЖЬ")
                Если ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
                    ЗначениеЯчейки = ПреобразоватьПростоеЗначениеИзСтрокиВТипизованноеЗначение1С(ЗначениеЯчейки);
                    Если ТипЗнч(ЗначениеЯчейки) = Тип("Строка") Тогда
                        ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
                    КонецЕсли;
                Иначе
                    ЗначениеЯчейки = Неопределено;
                    Если Область.Рисунки.Количество() > 0 Тогда    // Изображение.
                        ЗначениеЯчейки = ПолучитьЗначениеЯчейкиОбластиТабличногоДокументаСКартинками(Область, нСтрока, нКолонка, "УИД");
                    КонецЕсли;
                КонецЕсли;
            КонецПопытки;
            
            ИмяКолонки = "N" + нКолонка;
            НоваяСтрокаТФ[ИмяКолонки] = ЗначениеЯчейки;
            
            // Используется при формировании таблицы на форме обработки.
            ШиринаКолонки = ТаблицаРезультат.Колонки[ИмяКолонки].Ширина;
            ДлинаСтроки    = СтрДлина(СокрЛП(НоваяСтрокаТФ[ИмяКолонки]));
            ТаблицаРезультат.Колонки[ИмяКолонки].Ширина = ?(ШиринаКолонки < ДлинаСтроки, ДлинаСтроки, ШиринаКолонки);
			
			Если ТекущаяОбласть.Шрифт.Жирный Тогда
				НоваяСтрокаТФ.ВыделятьВСписке = Истина;
			КонецЕсли;	
	
        КонецЦикла;
    КонецЦикла;
    
    // Юзабилити. Удалить пустые колонки.
    УдалитьКолонкиСНулевойШириной(ТаблицаРезультат);
    
    Возврат ТаблицаРезультат;
    
КонецФункции

&НаСервере
Процедура УдалитьКолонкиСНулевойШириной(ТаблицаРезультат)
    Перем МассивПустыхКолонок;
    
    // Найдем пустые колонки.
    МассивПустыхКолонок = Новый Массив;
    Для Каждого Колонка ИЗ ТаблицаРезультат.Колонки Цикл
        Если Колонка.Ширина = 0 Тогда
            МассивПустыхКолонок.Добавить(Колонка.Имя);
        КонецЕсли;
    КонецЦикла;
    
    // Удалим пустые колонки.
    Для Каждого ПустаяКолонка ИЗ МассивПустыхКолонок Цикл
        ТаблицаРезультат.Колонки.Удалить(ПустаяКолонка);
    КонецЦикла;

КонецПроцедуры

// ПРЕОБРАЗОВАНИЕ СТРОКИ К ТИПИЗОВАННОМУ ЗНАЧЕНИЮ 1С.

&НаСервере
Функция ПреобразоватьПростоеЗначениеИзСтрокиВТипизованноеЗначение1С(Знач ИсходноеЗначение)
    
    Если НЕ ИсходноеЗначение = "" Тогда
        Если ТолькоЦифрыИЗапятаяВСтроке(ИсходноеЗначение, Истина, Ложь) Тогда
            Попытка
                Возврат Число(ИсходноеЗначение);
            Исключение
                Возврат ИсходноеЗначение
            КонецПопытки;
        Иначе
            Если ВРег(ИсходноеЗначение) = "ИСТИНА" ИЛИ ВРег(ИсходноеЗначение) = ("ИСТИНА"+Символы.ПС) ИЛИ ВРег(ИсходноеЗначение) = "TRUE" ИЛИ ВРег(ИсходноеЗначение) = ("TRUE"+Символы.ПС) Тогда
                Возврат Истина;
            ИначеЕсли ВРег(ИсходноеЗначение) = "ЛОЖЬ" ИЛИ  ВРег(ИсходноеЗначение) = ("ЛОЖЬ"+Символы.ПС) ИЛИ ВРег(ИсходноеЗначение) = "FALSE" ИЛИ ВРег(ИсходноеЗначение) = ("FALSE"+Символы.ПС) Тогда
                Возврат Ложь;
            Иначе
                Возврат ПреобразоватьИзСтрокиВДату(ИсходноеЗначение);
            КонецЕсли;
        КонецЕсли;
    КонецЕсли;
    
    Возврат ИсходноеЗначение
    
КонецФункции

// Проверяет, содержит ли строка только цифры и запятую.
//
// Параметры:
//  СтрокаПроверки          - Строка - Строка для проверки
//  УчитыватьЛидирующиеНули - Булево - Флаг учета лидирующих нулей, если Истина, то ведущие нули пропускаются
//  УчитыватьПробелы        - Булево - Флаг учета пробелов, если Истина, то пробелы при проверке игнорируются
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры или пустая, Ложь - строка содержит иные символы.
//
&НаСервере
Функция ТолькоЦифрыИЗапятаяВСтроке(Знач СтрокаПроверки, Знач УчитыватьЛидирующиеНули = Истина, Знач УчитыватьПробелы = Истина)
    
    Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
        Возврат Ложь;
    КонецЕсли;
    
    Если НЕ УчитыватьПробелы Тогда
        СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
    КонецЕсли;

     Если Сред(СтрокаПроверки, 1, 1) = "-" Тогда
        СтрокаПроверки = Сред(СтрокаПроверки, 2, СтрДлина(СтрокаПроверки));
     КонецЕсли;

     Если ПустаяСтрока(СтрокаПроверки) Тогда
       Возврат Истина;
    КонецЕсли;
    
    Если НЕ УчитыватьЛидирующиеНули Тогда
        Позиция = 1;
        // Взятие символа за границей строки возвращает пустую строку
        Пока Сред(СтрокаПроверки, Позиция, 1) = "0" Цикл
            Позиция = Позиция + 1;
        КонецЦикла;
        СтрокаПроверки = Сред(СтрокаПроверки, Позиция);
    КонецЕсли;
    
    // Если содержит только цифры, то в результате замен должна быть получена пустая строка
    // Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы
    Возврат СтрДлина(
        СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
        СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
            СтрокаПроверки, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", ""), ",", "")
    ) = 0;
    
КонецФункции

// Преобразование строки вида "01.01.13" или "01.01.2013" к значению типа "дата".
// Возможны друние форматы даты в файле EXCEL.
&НаСервере
Функция ПреобразоватьИзСтрокиВДату(Знач СтрокаДаты)
    Перем ScrptCtrl, OutDate;
    
    Попытка
        ScrptCtrl = Новый COMОбъект("MSScriptControl.ScriptControl");
        ScrptCtrl.Language="vbscript";
        OutDate = ScrptCtrl.Eval("CDate(""" + СтрокаДаты + """)");
        Возврат OutDate;
    Исключение
        //Сообщить(ОписаниеОшибки());
    КонецПопытки;
    
    Возврат СтрокаДаты;

КонецФункции 

// ПОЛУЧЕНИЕ ЗНАЧЕНИЯ ДЛЯ РЕКВИЗИТА ТИПА "ФАЙЛ КАРТИНКИ".

&НаСервере
Функция ПолучитьЗначениеЯчейкиОбластиТабличногоДокументаСКартинками(Знач Область, Знач нСтрока, Знач нКолонка, Знач ПравилоИмяФайлаКартинки = "УИД")
    Перем Рисунок, ит, ИмяФайлаРисунка;
    Перем ЗначениеЯчейки;
    
    ит = 0;
    ЗначениеЯчейки = "";
    Для Каждого Рисунок ИЗ Область.Рисунки Цикл
        ит = ит + 1;
        Если ПравилоИмяФайлаКартинки = "УИД" Тогда
            ИмяФайлаРисунка = КаталогВременныхФайлов() + Новый УникальныйИдентификатор() + ".jpg";
        Иначе
            ИмяФайлаРисунка = КаталогВременныхФайлов() + "С" + нСтрока + "К" + нКолонка + ".jpg";
        КонецЕсли;
        Попытка
            Рисунок.Картинка.Записать(ИмяФайлаРисунка);
            ЗначениеЯчейки = ЗначениеЯчейки + ИмяФайлаРисунка + ?(ит < Область.Рисунки.Количество(), Символы.ПС, "");
        Исключение
            // Поле картинки недоступно для чтения.
        КонецПопытки;
    КонецЦикла;
    
    Возврат ЗначениеЯчейки;
    
КонецФункции

#КонецОбласти

#Область ОбработчикиКомандФормы

&НаСервере
Процедура ПрочитатьФайлНаСервере(АдресФайла)
	
	ФайлНаСервере = ПолучитьИзВременногоХранилища(АдресФайла);
 	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xlsx");
 	ФайлНаСервере.Записать(ИмяВременногоФайла);
	
	ТЗ_ДанныеФайла = ЗагрузитьМетодом_1C836(ИмяВременногоФайла,,);
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	&ДанныеТЗ
	|ПОМЕСТИТЬ ВТ_ДанныеФайла
	|ИЗ
	|	&ТЗ_ДанныеФайла КАК ТЗ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	&ДанныеВТ
	|ИЗ
	|	ВТ_ДанныеФайла КАК ВТ_ДанныеФайла
	|ГДЕ
	|	&УсловиеСтроки
	|ИТОГИ ПО
	|	&КолонкиИтогов";

	
	ДанныеТЗ = "";
	ДанныеВТ = "";
	
	Для Каждого Колонка Из ТЗ_ДанныеФайла.Колонки Цикл
		Если Колонка.Имя <> "НомерСтроки" Тогда
			ДанныеВТ = ДанныеВТ+"
							|ВТ_ДанныеФайла."+Колонка.Имя+",";
		КонецЕсли;
		ДанныеТЗ = ДанныеТЗ+"
							|ТЗ."+Колонка.Имя+",";				
		
	КонецЦикла;
	
	ДанныеТЗ = Лев(ДанныеТЗ, СтрДлина(ДанныеТЗ)-1);
	ДанныеВТ = Лев(ДанныеВТ, СтрДлина(ДанныеВТ)-1);
		
	СтрокаИтогов = ТЗ_ДанныеФайла[0];
	КолонкиИтогов = "";
	Для Каждого Колонка Из ТЗ_ДанныеФайла.Колонки Цикл
		Если СтрокаИтогов[Колонка.Имя] = "1" Тогда
			КолонкиИтогов = КолонкиИтогов+"
							|ВТ_ДанныеФайла."+Колонка.Имя+",";
		КонецЕсли;
	КонецЦикла;
	
	КолонкиИтогов = Лев(КолонкиИтогов, СтрДлина(КолонкиИтогов)-1);
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ДанныеТЗ", ДанныеТЗ);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ДанныеВТ", ДанныеВТ);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&КолонкиИтогов", КолонкиИтогов);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеСтроки", "ВТ_ДанныеФайла.НомерСтроки > 2");
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("ТЗ_ДанныеФайла", ТЗ_ДанныеФайла); 
	
	Результат = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	КолонкаЕдИзм = Результат.Колонки.Количество()-2;
	КолонкаКоличество = Результат.Колонки.Количество()-1;
	
	ВывестиДанныеФайлаВДеревоЗначений(Результат);
	
КонецПроцедуры

&НаКлиенте
Процедура ПрочитатьФайл(Команда)
	
	Диалог = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	Если Диалог.Выбрать() Тогда
		АдресВременногоХранилища = "";
		Оповещение = Новый ОписаниеОповещения("ПрочитатьФайлЗавершение", ЭтотОбъект);
     	НачатьПомещениеФайла(Оповещение, АдресВременногоХранилища, Диалог.ПолноеИмяФайла, Ложь, ЭтаФорма.УникальныйИдентификатор);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ПрочитатьФайлЗавершение(Результат, Адрес, ВыбранноеИмяФайла, ДополнительныеПараметры) Экспорт
	
	АдресВременногоХранилища = Адрес;	
	ПрочитатьФайлНаСервере(АдресВременногоХранилища);

КонецПроцедуры

&НаСервере
Процедура ЗаполнитьВедомостьНаСервере()

	ОбходДереваДетально(РеквизитФормыВЗначение("Ведомость"));	
	Сообщить("Заполнение ведомости работ проекта <"+Проект+"> выполнено");
	
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьВедомость(Команда)
	
	ЗаполнитьВедомостьНаСервере();
		
КонецПроцедуры

#КонецОбласти

#Область РаботаСДеревом

&НаСервере
Функция ВывестиДанныеФайлаВДеревоЗначений(ДеревоДанных)
	
	МассивРеквизитов = Новый Массив;
	
	//Удалим ранее созданные колонки в ДЗ    
	КолонкиДЗ = РеквизитФормыВЗначение("Ведомость", Тип("ДеревоЗначений")).Колонки;
	Для Каждого Колонка Из КолонкиДЗ Цикл
	    МассивРеквизитов.Добавить("Ведомость." + Колонка.Имя);        
	КонецЦикла;
	ИзменитьРеквизиты(,МассивРеквизитов);
    
    //Удалим отображение таблицы на форме и создадим новую
    ЭлементТаблица = Элементы.Найти("Ведомость");
    Если ЭлементТаблица <> Неопределено Тогда
        Элементы.Удалить(ЭлементТаблица);        
    КонецЕсли;     
    
	ЭлементТаблица = Элементы.Добавить("Ведомость", Тип("ТаблицаФормы"));
	ЭлементТаблица.ПутьКДанным = "Ведомость";
	ЭлементТаблица.Отображение = ОтображениеТаблицы.Дерево;
	ЭлементТаблица.ИзменятьПорядокСтрок = Ложь;
	ЭлементТаблица.ИзменятьСоставСтрок = Ложь;
	
    //Создадим реквизиты ДЗ
    МассивРеквизитов.Очистить();
    Для Каждого Колонка Из ДеревоДанных.Колонки Цикл
        МассивТипов = Новый Массив;
        МассивТипов.Добавить(Колонка.ТипЗначения);
        НоваяКолонка = Новый РеквизитФормы(Колонка.Имя, Новый ОписаниеТипов(МассивТипов), "Ведомость");
        МассивРеквизитов.Добавить(НоваяКолонка);
	КонецЦикла;      
	
    ИзменитьРеквизиты(МассивРеквизитов);  
    ЗначениеВРеквизитФормы(ДеревоДанных, "Ведомость");
    
	//Создаем элементы на форме для отображения колонок
	ЭлементДЗ = Элементы.Ведомость;
	Для Каждого Колонка ИЗ ДеревоДанных.Колонки Цикл
	    НовыйЭлементФормы = Элементы.Добавить("Ведомость"+Колонка.Имя, Тип("ПолеФормы"), ЭлементДЗ);
	    НовыйЭлементФормы.Вид = ВидПоляФормы.ПолеВвода;
	    НовыйЭлементФормы.ПутьКДанным = "Ведомость." + Колонка.Имя;
	КонецЦикла;
        
КонецФункции

&НаСервере
Процедура ОбходДереваДетально(ПереданноеДерево, Родитель = "")
	
	Для Каждого СтрокаДерева Из ПереданноеДерево.Строки Цикл
		
		Если СтрокаДерева.Строки.Количество()>0 Тогда
			
			НГруппа = Справочники.РеестрыРабот.СоздатьГруппу();
			НГруппа.Владелец		= Проект;
			НГруппа.Наименование 	= СтрокаДерева[СтрокаДерева.Уровень()];
			НГруппа.Родитель 		= ?(Родитель = "", Справочники.РеестрыРабот.ПустаяСсылка(), Родитель);
			НГруппа.Записать();
			
			ОбходДереваДетально(СтрокаДерева, НГруппа.Ссылка);
			
		Иначе
			
			НЭлемент = Справочники.РеестрыРабот.СоздатьЭлемент();
			НЭлемент.Владелец		= Проект;
			НЭлемент.Наименование 	= СтрокаДерева[СтрокаДерева.Уровень()];
			НЭлемент.Родитель 		= ?(Родитель = "", Справочники.РеестрыРабот.ПустаяСсылка(), Родитель);
			НЭлемент.Количество 	= СтрокаДерева["N"+КолонкаКоличество];
			НЭлемент.ВыделятьВСписке = СтрокаДерева.ВыделятьВСписке;
			
			ИскЕдИзм = Справочники.ЕдиницыИзмерений.НайтиПоНаименованию(СтрокаДерева["N"+КолонкаЕдИзм]);
			Если ИскЕдИзм = Неопределено Тогда
				ИскЕдИзм = Справочники.ЕдиницыИзмерений.СоздатьЭлемент();
				ИскЕдИзм.Наименование = СтрокаДерева["N"+КолонкаЕдИзм];
				ИскЕдИзм.УстановитьНовыйКод();
				ИскЕдИзм.Записать();
			КонецЕсли;	
				
			НЭлемент.ЕдиницаИзмерения = ИскЕдИзм.Ссылка;
			НЭлемент.Записать();
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти



